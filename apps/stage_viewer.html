<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ChordPro Studio – Stage Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- PWA -->
  <link rel="manifest" href="./manifest.json">
  <link rel="apple-touch-icon" href="./icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#111111">

  <style>
    :root{
      --bg:#0f1115;
      --panel:#171a21;
      --card:#1f2430;
      --text:#f5f7ff;
      --muted:#aab2c5;
      --border:rgba(255,255,255,0.10);
      --accent:#6aa3ff;
      --accent2:#7ee787;
      --danger:#ff6a6a;

      --songbg:#0b0d12;
      --songborder:rgba(255,255,255,0.12);
      --chord:#ffd479;
    }
    body.light{
      --bg:#f2f3f6;
      --panel:#ffffff;
      --card:#ffffff;
      --text:#121418;
      --muted:#5c6472;
      --border:rgba(0,0,0,0.12);
      --accent:#2a66ff;
      --accent2:#1f8a3b;
      --danger:#c92828;

      --songbg:#ffffff;
      --songborder:rgba(0,0,0,0.14);
      --chord:#b05a00;
    }

    body{
      margin:0;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    header{
      position:sticky;
      top:0;
      z-index:10;
      background:var(--panel);
      border-bottom:1px solid var(--border);
      padding:10px 14px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .brand{ font-weight:700; letter-spacing:0.2px; margin-right:auto; }

    select, button{
      background:var(--card);
      color:var(--text);
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px 10px;
      font-size:14px;
      outline:none;
    }
    button{ cursor:pointer; }
    button:hover{ border-color:rgba(255,255,255,0.22); }
    body.light button:hover{ border-color:rgba(0,0,0,0.22); }

    .miniLabel{ color:var(--muted); font-size:12px; margin-right:6px; }
    body.perf .miniLabel{ display:none; }

    main{
      padding:14px;
      max-width:1200px;
      margin:0 auto;
      box-sizing:border-box;
    }

    .status{
      font-size:13px;
      color:var(--muted);
      margin-bottom:10px;
    }
    body.perf .status{ display:none; }

    /* Summary strip */
    .summaryStrip{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px 12px;
      margin:0 0 12px 0;
    }
    body.perf .summaryStrip{ display:none; }

    .summaryStrip .k{ color:var(--muted); font-size:12px; }
    .summaryStrip .v{ font-weight:800; }
    .summaryStrip .spacer{ margin-left:auto; }

    .pill{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
      font-size:12px;
      margin-left:6px;
      white-space:nowrap;
    }

    .layout{
      display:grid;
      grid-template-columns: 1fr 1.15fr;
      gap:12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
    }

    /* Table wrapper makes header sticky reliably */
    .tableWrap{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      overflow:auto;
      max-height: calc(100vh - 180px);
    }
    body.perf .tableWrap{
      max-height: calc(100vh - 120px);
    }

    table{
      width:100%;
      border-collapse:collapse;
      background:var(--card);
    }
    th, td{
      text-align:left;
      padding:12px 12px;
      border-bottom:1px solid var(--border);
      font-size:14px;
      vertical-align:top;
    }
    body.perf td{
      font-size:15px;
      padding:14px 12px;
    }

    th{
      position:sticky;
      top:0;
      z-index:2;
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:0.08em;
      color:var(--muted);
      background:rgba(255,255,255,0.06);
      backdrop-filter: blur(6px);
    }
    body.light th{ background:rgba(0,0,0,0.06); }

    tr.clickable{ cursor:pointer; }
    tr.clickable:hover td{
      background: rgba(106,163,255,0.10);
    }
    body.light tr.clickable:hover td{
      background: rgba(42,102,255,0.08);
    }
    tr.selected td{
      background: rgba(126,231,135,0.12);
    }
    body.light tr.selected td{
      background: rgba(31,138,59,0.10);
    }

    .songPanel{
      background:var(--songbg);
      border:1px solid var(--songborder);
      border-radius:14px;
      overflow:hidden;
      display:none;
    }

    .songHeader{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      padding:10px 12px;
      background:var(--card);
      border-bottom:1px solid var(--border);
    }
    .songTitle{ font-weight:900; font-size:16px; }
    body.perf .songTitle{ font-size:18px; }
    .songMeta{ color:var(--muted); font-size:12px; }
    body.perf .songMeta{ font-size:13px; }

    .songNav{
      margin-left:auto;
      display:flex;
      gap:8px;
      align-items:center;
    }

    .songBody{
      padding:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:16px;
      line-height:1.35;
      white-space:pre-wrap;
      word-break:break-word;
    }
    body.perf .songBody{ font-size:18px; line-height:1.42; }

    .line{ display:block; padding:1px 0; }
    .chord{ color:var(--chord); font-weight:900; }
    .section{
      color:var(--accent2);
      font-weight:900;
      margin-top:10px;
      display:block;
    }
    .warn{ color:var(--danger); font-weight:800; }
  </style>
</head>

<body>
  <header>
    <div class="brand">Stage Viewer</div>

    <label>
      <span class="miniLabel">Collection</span>
      <select id="collectionSelect" disabled>
        <option>Loading…</option>
      </select>
    </label>

    <label>
      <span class="miniLabel">Set</span>
      <select id="setSelect" disabled>
        <option>Loading…</option>
      </select>
    </label>

    <label>
      <span class="miniLabel">Persona</span>
      <select id="personaSelect" disabled>
        <option>Loading…</option>
      </select>
    </label>

    <button id="refreshBtn" title="Reload library index">Refresh</button>
    <button id="perfBtn" title="Toggle performance mode">Performance</button>
    <button id="themeBtn" title="Toggle light/dark">Theme</button>
  </header>

  <main>
    <div class="status" id="status">Loading library…</div>

    <div class="summaryStrip" id="summaryStrip" style="display:none;"></div>

    <div class="layout" id="layout" style="display:none;">
      <div class="tableWrap">
        <table>
          <thead>
            <tr>
              <th style="width:6%;">#</th>
              <th style="width:52%;">Song</th>
              <th style="width:18%;">Singer</th>
              <th style="width:10%;">Dur</th>
              <th style="width:7%;">Capo</th>
              <th style="width:7%;">Key</th>
            </tr>
          </thead>
          <tbody id="songRows"></tbody>
        </table>
      </div>

      <div class="songPanel" id="songPanel">
        <div class="songHeader">
          <div>
            <div class="songTitle" id="songTitle">—</div>
            <div class="songMeta" id="songMeta">—</div>
          </div>
          <div class="songNav">
            <button id="prevBtn" title="Previous song">Prev</button>
            <button id="nextBtn" title="Next song">Next</button>
          </div>
        </div>
        <div class="songBody" id="songBody"></div>
      </div>
    </div>
  </main>

  <script>
    // --- PWA SW ---
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./serviceWorker.js').catch(() => {});
    }

    // --- Theme ---
    const themeBtn = document.getElementById('themeBtn');
    themeBtn.addEventListener('click', () => {
      document.body.classList.toggle('light');
      localStorage.setItem('cps_theme', document.body.classList.contains('light') ? 'light' : 'dark');
    });
    (function initTheme(){
      const t = localStorage.getItem('cps_theme');
      if (t === 'light') document.body.classList.add('light');
    })();

    // --- Performance mode ---
    const perfBtn = document.getElementById('perfBtn');
    perfBtn.addEventListener('click', () => {
      document.body.classList.toggle('perf');
      localStorage.setItem('cps_perf', document.body.classList.contains('perf') ? '1' : '0');
    });
    (function initPerf(){
      const p = localStorage.getItem('cps_perf');
      if (p === '1') document.body.classList.add('perf');
    })();

    // --- DOM ---
    const statusEl = document.getElementById('status');
    const summaryStrip = document.getElementById('summaryStrip');

    const collectionSelect = document.getElementById('collectionSelect');
    const setSelect = document.getElementById('setSelect');
    const personaSelect = document.getElementById('personaSelect');
    const refreshBtn = document.getElementById('refreshBtn');

    const songRows = document.getElementById('songRows');
    const layout = document.getElementById('layout');

    const songPanel = document.getElementById('songPanel');
    const songTitleEl = document.getElementById('songTitle');
    const songMetaEl = document.getElementById('songMeta');
    const songBodyEl = document.getElementById('songBody');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');

    // --- State ---
    let LIB = null;
    let SONG_MAP = new Map();

    let CURRENT_COLLECTION_ID = null;
    let CURRENT_SET_ID = null;

    let CURRENT_UID_ORDER = [];
    let CURRENT_UID = null;

    function setStatus(msg){ statusEl.textContent = msg; }

    async function fetchJSON(url){
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.json();
    }
    async function fetchText(url){
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.text();
    }

    function unique(arr){
      return Array.from(new Set(arr)).filter(Boolean);
    }

    function escapeHtml(str){
      return String(str)
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'",'&#039;');
    }

    function fmtDurationToSeconds(d){
      if (!d) return 0;
      const s = String(d).trim();
      const m = /^(\d+)\s*:\s*(\d{1,2})$/.exec(s);
      if (!m) return 0;
      const mins = parseInt(m[1], 10);
      const secs = parseInt(m[2], 10);
      if (Number.isNaN(mins) || Number.isNaN(secs)) return 0;
      return mins * 60 + secs;
    }
    function fmtSeconds(sec){
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return `${m}:${String(s).padStart(2,'0')}`;
    }

    function buildSongMap(){
      SONG_MAP = new Map();
      (LIB.songs || []).forEach(s => {
        if (s && s.uid) SONG_MAP.set(String(s.uid), s);
      });
    }

    function computePersonas(){
      const p = [];
      (LIB.songs || []).forEach(s => {
        if (Array.isArray(s.personas)) p.push(...s.personas);
        if (s.files && typeof s.files === 'object') {
          Object.keys(s.files).forEach(k => { if (k && k !== '_default') p.push(k); });
        }
      });
      return unique(p).sort((a,b)=>a.localeCompare(b));
    }

    function adaptLegacySetlistsToCollections(){
      if (Array.isArray(LIB.collections)) return;
      if (!Array.isArray(LIB.setlists)) { LIB.collections = []; return; }

      LIB.collections = LIB.setlists.map(sl => ({
        id: sl.id || sl.name || '',
        type: 'gig',
        name: sl.name || sl.id || '(unnamed)',
        notes: sl.notes || '',
        sets: Array.isArray(sl.sets) ? sl.sets.map((s, idx) => ({
          id: s.id || `set${idx+1}`,
          name: s.name || `Set ${idx+1}`,
          songs: Array.isArray(s.songs) ? s.songs.map(String) : []
        })) : []
      }));
    }

    function ensureSmartAllSongsCollection(){
      if (!Array.isArray(LIB.collections)) LIB.collections = [];
      if (!LIB.collections.some(c => String(c.id) === '_all_songs')){
        LIB.collections.unshift({
          id: "_all_songs",
          type: "smart",
          name: "All Songs",
          rules: { mode: "all_songs" },
          sets: []
        });
      }
    }

    function getCollections(){
      return Array.isArray(LIB.collections) ? LIB.collections : [];
    }
    function findCollectionById(id){
      return getCollections().find(c => String(c.id) === String(id));
    }
    function isSmartCollection(c){ return c && c.type === 'smart'; }

    function computeAllSongsUidList(){
      const uids = Array.from(SONG_MAP.keys());
      uids.sort((a,b)=>{
        const sa = SONG_MAP.get(a), sb = SONG_MAP.get(b);
        const ta = (sa?.title||"").toLowerCase(), tb = (sb?.title||"").toLowerCase();
        const aa = (sa?.artist||"").toLowerCase(), ab = (sb?.artist||"").toLowerCase();
        if (ta !== tb) return ta.localeCompare(tb);
        if (aa !== ab) return aa.localeCompare(ab);
        return a.localeCompare(b);
      });
      return uids;
    }

    function getSetsForCollection(col){
      if (!col) return [];
      if (isSmartCollection(col)){
        const mode = col.rules?.mode;
        if (mode === 'all_songs'){
          return [{ id:"all", name:"All Songs", songs: computeAllSongsUidList() }];
        }
        return [];
      }
      const sets = Array.isArray(col.sets) ? col.sets : [];
      return sets.map((s, idx) => ({
        id: s.id || `set${idx+1}`,
        name: s.name || `Set ${idx+1}`,
        songs: Array.isArray(s.songs) ? s.songs.map(String) : []
      }));
    }

    function findSetInCollection(col, setId){
      const sets = getSetsForCollection(col);
      return sets.find(s => String(s.id) === String(setId)) || null;
    }

    function populatePersonaSelect(){
      const personas = computePersonas();
      personaSelect.innerHTML = '';
      if (!personas.length){
        personaSelect.innerHTML = '<option value="">(none)</option>';
        personaSelect.disabled = true;
        return;
      }
      personas.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p;
        opt.textContent = p;
        personaSelect.appendChild(opt);
      });

      const saved = localStorage.getItem('cps_persona');
      if (saved && personas.includes(saved)) personaSelect.value = saved;

      personaSelect.disabled = false;
    }

    function populateCollectionSelect(){
      collectionSelect.innerHTML = '';
      const cols = getCollections();
      if (!cols.length){
        collectionSelect.innerHTML = '<option value="">(no collections)</option>';
        collectionSelect.disabled = true;
        return;
      }
      cols.forEach(c => {
        const opt = document.createElement('option');
        opt.value = String(c.id);
        opt.textContent = c.name || c.id || '(unnamed)';
        collectionSelect.appendChild(opt);
      });

      const values = cols.map(c => String(c.id));
      const saved = localStorage.getItem('cps_collection');
      const pick = (saved && values.includes(saved)) ? saved : values[0];

      collectionSelect.value = pick;
      CURRENT_COLLECTION_ID = pick;
      collectionSelect.disabled = false;
    }

    function populateSetSelect(){
      setSelect.innerHTML = '';
      const col = findCollectionById(CURRENT_COLLECTION_ID);
      const sets = getSetsForCollection(col);

      if (!sets.length){
        setSelect.innerHTML = '<option value="">(no sets)</option>';
        setSelect.disabled = true;
        CURRENT_SET_ID = null;
        return;
      }

      sets.forEach(s => {
        const opt = document.createElement('option');
        opt.value = String(s.id);
        opt.textContent = s.name || s.id || '(unnamed set)';
        setSelect.appendChild(opt);
      });

      const values = sets.map(s => String(s.id));
      const savedKey = `cps_set_${String(CURRENT_COLLECTION_ID)}`;
      const saved = localStorage.getItem(savedKey);
      const pick = (saved && values.includes(saved)) ? saved : values[0];

      setSelect.value = pick;
      CURRENT_SET_ID = pick;
      setSelect.disabled = false;
    }

    function selectRow(uid){
      const rows = songRows.querySelectorAll('tr[data-uid]');
      rows.forEach(r => r.classList.toggle('selected', r.getAttribute('data-uid') === uid));
    }

    function buildUidOrder(){
      const col = findCollectionById(CURRENT_COLLECTION_ID);
      const set = findSetInCollection(col, CURRENT_SET_ID);
      return Array.isArray(set?.songs) ? set.songs.map(String) : [];
    }

    function computeSetDuration(uids){
      let total = 0;
      for (const uid of (uids || [])){
        const s = SONG_MAP.get(String(uid));
        total += fmtDurationToSeconds(s?.duration);
      }
      return total;
    }

    function computeSingerCounts(uids){
      const counts = {};
      for (const uid of (uids || [])){
        const s = SONG_MAP.get(String(uid));
        const singer = (s?.singer || '').trim();
        if (!singer) continue;
        counts[singer] = (counts[singer] || 0) + 1;
      }
      return counts;
    }

    function renderSummaryStrip(){
      const col = findCollectionById(CURRENT_COLLECTION_ID);
      const set = findSetInCollection(col, CURRENT_SET_ID);

      if (!col || !set){
        summaryStrip.style.display = 'none';
        return;
      }

      const uids = Array.isArray(set.songs) ? set.songs : [];
      const totalSec = computeSetDuration(uids);
      const singerCounts = computeSingerCounts(uids);
      const singerKeys = Object.keys(singerCounts).sort((a,b)=>a.localeCompare(b));

      let singerHtml = '';
      if (singerKeys.length > 1){
        singerHtml = singerKeys.map(k => `<span class="pill">${escapeHtml(k)}: <b>${singerCounts[k]}</b></span>`).join(' ');
      } else if (singerKeys.length === 1){
        // keep it minimal if only one singer
        singerHtml = `<span class="pill">${escapeHtml(singerKeys[0])}: <b>${singerCounts[singerKeys[0]]}</b></span>`;
      }

      summaryStrip.innerHTML = `
        <span class="k">Now:</span>
        <span class="v">${escapeHtml(col.name || col.id)}</span>
        <span class="k">→</span>
        <span class="v">${escapeHtml(set.name || set.id)}</span>

        <span class="pill">Songs: <b>${uids.length}</b></span>
        <span class="pill">Set: <b>${fmtSeconds(totalSec)}</b></span>
        ${singerHtml ? singerHtml : ''}

        <span class="spacer"></span>
        <span class="k">Consolidated:</span>
        <span class="v">${escapeHtml(LIB.lastConsolidated || '—')}</span>
      `;
      summaryStrip.style.display = 'flex';
    }

    function renderSongTable(){
      const col = findCollectionById(CURRENT_COLLECTION_ID);
      const set = findSetInCollection(col, CURRENT_SET_ID);

      if (!col){
        setStatus('No collection selected.');
        songRows.innerHTML = '';
        layout.style.display = 'none';
        summaryStrip.style.display = 'none';
        return;
      }
      if (!set){
        setStatus('No set selected.');
        songRows.innerHTML = '';
        layout.style.display = 'none';
        summaryStrip.style.display = 'none';
        return;
      }

      CURRENT_UID_ORDER = buildUidOrder();
      songRows.innerHTML = '';

      let missing = 0;

      CURRENT_UID_ORDER.forEach((uid, idx) => {
        const s = SONG_MAP.get(uid);
        const tr = document.createElement('tr');
        tr.className = 'clickable';
        tr.setAttribute('data-uid', uid);

        if (!s){
          missing++;
          tr.innerHTML = `
            <td>${idx+1}</td>
            <td><b class="warn">Missing song</b> <span class="pill">${escapeHtml(uid)}</span></td>
            <td>—</td><td>—</td><td>—</td><td>—</td>
          `;
          tr.addEventListener('click', () => setStatus(`Missing song UID: ${uid}`));
        } else {
          const title = s.title || '(untitled)';
          const artist = s.artist || '(unknown)';
          const singer = s.singer || '—';
          const duration = s.duration || '—';

          // Capo/Key: prefer song fields if present, otherwise blank (we show true meta on open)
          const capo = (s.capo ?? '').toString().trim();
          const key  = (s.key  ?? '').toString().trim();

          tr.innerHTML = `
            <td>${idx+1}</td>
            <td><b>${escapeHtml(title)}</b> <span class="pill">${escapeHtml(artist)}</span></td>
            <td>${escapeHtml(singer)}</td>
            <td>${escapeHtml(String(duration))}</td>
            <td>${escapeHtml(capo || '—')}</td>
            <td>${escapeHtml(key || '—')}</td>
          `;
          tr.addEventListener('click', () => openSong(uid));
        }

        songRows.appendChild(tr);
      });

      layout.style.display = 'grid';
      renderSummaryStrip();

      const persona = personaSelect.value || '(none)';
      const msg = `Loaded: ${col.name || col.id} → ${set.name || set.id} • Songs: ${CURRENT_UID_ORDER.length}` +
                  (missing ? ` • Missing: ${missing}` : '') +
                  ` • Persona: ${persona}`;
      setStatus(msg);
    }

    function resolveChoPathForPersona(song, persona){
      if (song?.files && typeof song.files === 'object'){
        if (persona && song.files[persona]) return song.files[persona];
        if (song.files["_default"]) return song.files["_default"];
        const keys = Object.keys(song.files);
        if (keys.length) return song.files[keys[0]];
      }
      return null;
    }

    function parseChordProMeta(text){
      const meta = {};
      const tagRe = /^\s*\{([a-zA-Z0-9_\-]+)\s*:\s*(.*?)\}\s*$/;
      for (const line of text.split('\n')){
        const m = tagRe.exec(line);
        if (!m) continue;
        const k = m[1].trim().toLowerCase();
        const v = m[2].trim();
        if (!(k in meta)) meta[k] = v;
      }
      return meta;
    }

    function chordProToHtml(text){
      const lines = text.split('\n');
      const out = [];

      const isTag = (line) => /^\s*\{[^\}]+\}\s*$/.test(line);

      for (let raw of lines){
        const line = raw.replace(/\r$/, '');

        if (/^\s*\{soc\}\s*$/i.test(line) || /^\s*\{start_of_chorus\}\s*$/i.test(line)){
          out.push(`<span class="section">[CHORUS]</span>`);
          continue;
        }
        if (/^\s*\{eoc\}\s*$/i.test(line) || /^\s*\{end_of_chorus\}\s*$/i.test(line)){
          out.push(`<span class="section">[/CHORUS]</span>`);
          continue;
        }

        const mComment = /^\s*\{(?:c|comment)\s*:\s*(.*?)\}\s*$/i.exec(line);
        if (mComment){
          out.push(`<span class="section">${escapeHtml(mComment[1])}</span>`);
          continue;
        }

        if (isTag(line)) continue;

        const html = escapeHtml(line).replace(/\[([^\]]+)\]/g, (_m, chord) => {
          return `<span class="chord">[${escapeHtml(chord)}]</span>`;
        });

        out.push(`<span class="line">${html || '&nbsp;'}</span>`);
      }

      return out.join('');
    }

    async function openSong(uid){
      const song = SONG_MAP.get(uid);
      if (!song){
        setStatus(`Missing song UID: ${uid}`);
        return;
      }

      const persona = personaSelect.value || '';
      const choRel = resolveChoPathForPersona(song, persona);
      if (!choRel){
        setStatus(`No .cho file found for UID ${uid} (persona "${persona}")`);
        songPanel.style.display = 'none';
        return;
      }

      try{
        const url = choRel.startsWith("../") ? choRel : ("../" + choRel);

        setStatus(`Loading song… (${url})`);
        const choText = await fetchText(url);

        const meta = parseChordProMeta(choText);

        const title = song.title || meta.title || '(untitled)';
        const artist = song.artist || meta.artist || '(unknown)';

        const singer = (meta.singer || song.singer || '—');
        const capo = (meta.capo || song.capo || '');
        const key = (meta.key || song.key || '');
        const tempo = (meta.tempo || song.tempo || '');
        const duration = (meta.duration || song.duration || '');

        songTitleEl.textContent = `${title} — ${artist}`;

        // Stage-first ordering
        songMetaEl.textContent =
          `Singer: ${singer}` +
          (capo ? ` | Capo: ${capo}` : '') +
          (key ? ` | Key: ${key}` : '') +
          (tempo ? ` | Tempo: ${tempo}` : '') +
          (duration ? ` | Duration: ${duration}` : '') +
          ` | Persona: ${persona || '—'}` +
          ` | UID: ${uid}`;

        songBodyEl.innerHTML = chordProToHtml(choText);
        songPanel.style.display = 'block';

        CURRENT_UID = uid;
        selectRow(uid);
        setStatus(`Loaded: ${title} — ${artist}`);
      }catch(e){
        console.error(e);
        setStatus(`Failed to load song UID ${uid}: ${e.message}`);
        songPanel.style.display = 'none';
      }
    }

    function navDelta(delta){
      if (!CURRENT_UID_ORDER.length) return;
      const i = CURRENT_UID ? CURRENT_UID_ORDER.indexOf(CURRENT_UID) : -1;
      const nextIndex = (i < 0) ? 0 : Math.min(Math.max(i + delta, 0), CURRENT_UID_ORDER.length - 1);
      const uid = CURRENT_UID_ORDER[nextIndex];
      if (uid) openSong(uid);
    }
    prevBtn.addEventListener('click', () => navDelta(-1));
    nextBtn.addEventListener('click', () => navDelta(1));

    async function loadLibrary(){
      setStatus('Loading library index…');
      collectionSelect.disabled = true;
      setSelect.disabled = true;
      personaSelect.disabled = true;
      summaryStrip.style.display = 'none';
      layout.style.display = 'none';
      songPanel.style.display = 'none';
      songRows.innerHTML = '';
      CURRENT_UID = null;
      CURRENT_UID_ORDER = [];

      try{
        LIB = await fetchJSON('../library/library.index.json');
        buildSongMap();

        adaptLegacySetlistsToCollections();
        ensureSmartAllSongsCollection();

        populatePersonaSelect();
        populateCollectionSelect();
        populateSetSelect();

        // Restore previous selections
        const savedCol = localStorage.getItem('cps_collection');
        if (savedCol && getCollections().some(c => String(c.id) === String(savedCol))){
          collectionSelect.value = savedCol;
          CURRENT_COLLECTION_ID = savedCol;
          populateSetSelect();
        }

        renderSongTable();

        // Auto-open first song
        if (CURRENT_UID_ORDER.length){
          const first = CURRENT_UID_ORDER[0];
          if (SONG_MAP.get(first)) openSong(first);
        }

      }catch(e){
        console.error(e);
        setStatus(`Failed to load library: ${e.message}`);
      }
    }

    refreshBtn.addEventListener('click', loadLibrary);

    collectionSelect.addEventListener('change', () => {
      CURRENT_COLLECTION_ID = collectionSelect.value;
      localStorage.setItem('cps_collection', CURRENT_COLLECTION_ID);

      populateSetSelect();
      const savedKey = `cps_set_${String(CURRENT_COLLECTION_ID)}`;
      localStorage.removeItem(savedKey);

      CURRENT_UID = null;
      renderSongTable();
      if (CURRENT_UID_ORDER.length){
        const first = CURRENT_UID_ORDER[0];
        if (SONG_MAP.get(first)) openSong(first);
      }
    });

    setSelect.addEventListener('change', () => {
      CURRENT_SET_ID = setSelect.value;
      const savedKey = `cps_set_${String(CURRENT_COLLECTION_ID)}`;
      localStorage.setItem(savedKey, CURRENT_SET_ID);

      CURRENT_UID = null;
      renderSongTable();
      if (CURRENT_UID_ORDER.length){
        const first = CURRENT_UID_ORDER[0];
        if (SONG_MAP.get(first)) openSong(first);
      }
    });

    personaSelect.addEventListener('change', () => {
      localStorage.setItem('cps_persona', personaSelect.value);
      if (CURRENT_UID) openSong(CURRENT_UID);
      else renderSongTable();
    });

    loadLibrary();
  </script>
</body>
</html>
