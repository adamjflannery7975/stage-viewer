<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Stage Viewer">
<link rel="manifest" href="manifest.json">
<title>ChordPro Stage Viewer Mobile v1.0</title>
<style>
/* GLOBAL THEME BLOCK */
:root {
  --bg: #0b0f14;
  --panel: #0f1620;
  --panel2: #0c121b;
  --text: #e8eef7;
  --muted: #9fb0c7;
  --line: #223144;
  --accent: #00bcd4;
  --accent2: #3b82f6;
  --danger: #e11d48;
  --ok: #22c55e;
  --shadow: 0 10px 30px rgba(0,0,0,.35);
  --radius: 12px;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;

  /* Stage Viewer tokens */
  --ui-bg: var(--panel);
  --ui-card: var(--panel2);
  --ui-accent: var(--accent2);
  --ui-text: var(--text);

  /* Sheet rendering */
  --ipad-bg: #000;
  --chord-clr: #00ffff;
  --section-clr: #ffff00;
  --chorus-clr: #ff6b6b;
  --lyric-clr: #fff;
  --font-size: 24px;
  --line-height: 1.4;
}

* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: var(--sans);
  background: linear-gradient(180deg, #07101a 0%, #05070b 100%);
  color: var(--text);
  display: flex;
  height: 100vh;
  overflow: hidden;
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
}

a { color: var(--accent2); }
button, select, input, textarea { font-family: inherit; }

/* Sidebar */
#sidebar {
  width: 320px;
  background: rgba(10,16,24,.92);
  backdrop-filter: blur(8px);
  border-right: 1px solid var(--line);
  display: flex;
  flex-direction: column;
  z-index: 10;
  transition: transform 0.3s ease;
}

.sidebar-header {
  padding: 14px;
  border-bottom: 1px solid var(--line);
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#setlistItems {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}

/* Inputs */
select, input[type="text"] {
  width: 100%;
  appearance: none;
  border: 1px solid #2a3a50;
  background: linear-gradient(180deg, #1b2a3d 0%, #152234 100%);
  color: var(--text);
  padding: 9px 10px;
  border-radius: 10px;
  font-weight: 700;
  font-size: 13px;
  outline: none;
}

select:focus, input[type="text"]:focus {
  box-shadow: 0 0 0 3px rgba(59,130,246,.25);
}

/* Song cards */
.song-card {
  background: linear-gradient(180deg, rgba(15,22,32,.9) 0%, rgba(12,18,27,.9) 100%);
  border: 1px solid var(--line);
  border-radius: var(--radius);
  padding: 12px;
  margin-bottom: 10px;
  cursor: pointer;
  box-shadow: 0 6px 18px rgba(0,0,0,.25);
  min-height: 44px;
}

.song-card:hover {
  border-color: #2f4766;
}

.song-card.active {
  border-color: var(--accent2);
  box-shadow: 0 0 0 3px rgba(59,130,246,.22), 0 10px 26px rgba(0,0,0,.35);
}

.song-card b {
  display: block;
  font-size: 14px;
  color: var(--text);
}

.song-card small {
  display: block;
  font-size: 11px;
  color: var(--muted);
  margin-top: 4px;
}

/* Stage */
#stage {
  flex: 1;
  display: flex;
  flex-direction: column;
  position: relative;
}

.stage-bar {
  height: 65px;
  background: rgba(10,16,24,.92);
  backdrop-filter: blur(8px);
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 16px;
  border-bottom: 1px solid var(--line);
  flex-shrink: 0;
}

.title-line {
  font-weight: 800;
  font-size: 18px;
  color: var(--text);
}

.artist-inline {
  font-weight: 600;
  opacity: .7;
  margin-left: 10px;
  font-size: 14px;
  color: var(--muted);
}

.meta-badges {
  display: flex;
  gap: 8px;
  margin-top: 4px;
  justify-content: center;
}

.badge {
  background: linear-gradient(180deg, #2563eb 0%, #1d4ed8 100%);
  border: 1px solid #2a3a50;
  color: white;
  padding: 2px 8px;
  border-radius: 6px;
  font-size: 10px;
  font-weight: 800;
  text-transform: uppercase;
}

/* Viewer area */
#viewer {
  flex: 1;
  overflow-y: scroll;
  padding: 10px 10px 40px 10px;
  white-space: pre-wrap;
  font-size: var(--font-size);
  line-height: var(--line-height);
  color: var(--lyric-clr);
  scroll-behavior: smooth;
  background: transparent;
  -webkit-user-select: text;
  user-select: text;
  -webkit-overflow-scrolling: touch;
}

.p-chord {
  color: var(--chord-clr);
  font-weight: 800;
  position: relative;
  top: -0.2em;
}

.p-section {
  color: var(--section-clr);
  font-weight: 800;
  display: block;
  margin-top: 0.6em;
  border-bottom: none !important;
}

.chorus-container {
  border-left: 4px solid var(--chorus-clr);
  padding-left: 20px;
  margin: 10px 0;
  color: var(--chorus-clr) !important;
}

/* Options panel */
#viewOptions {
  position: absolute;
  top: 75px;
  right: 20px;
  background: rgba(15,22,32,.96);
  border: 1px solid var(--line);
  padding: 18px;
  border-radius: 14px;
  display: none;
  width: 280px;
  z-index: 1000;
  box-shadow: var(--shadow);
}

.opt-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 14px;
  font-size: 12px;
  color: var(--text);
}

.opt-row label {
  flex: 1;
  color: var(--muted);
  font-weight: 700;
}

.opt-row input[type="range"] {
  flex: 1.5;
  margin: 0 10px;
  accent-color: var(--accent2);
}

/* Buttons */
.btn, .btn-nav {
  appearance: none;
  border: 1px solid #2a3a50;
  background: linear-gradient(180deg, #1b2a3d 0%, #152234 100%);
  color: var(--text);
  padding: 9px 12px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 800;
  font-size: 13px;
  box-shadow: 0 8px 20px rgba(0,0,0,.25);
  display: inline-flex;
  align-items: center;
  gap: 8px;
  user-select: none;
  min-height: 44px;
}

.btn:hover, .btn-nav:hover {
  filter: brightness(1.05);
  border-color: #3b82f6;
}

.btn:active, .btn-nav:active {
  transform: translateY(1px);
}

.btn-fab {
  width: 55px;
  height: 55px;
  border-radius: 14px;
  background: linear-gradient(180deg, #2563eb 0%, #1d4ed8 100%);
  border: 1px solid #2a3a50;
  color: white;
  font-size: 20px;
  position: fixed;
  right: 20px;
  cursor: pointer;
  z-index: 900;
  box-shadow: 0 14px 30px rgba(0,0,0,.35);
  opacity: .92;
  display: flex;
  align-items: center;
  justify-content: center;
}

.btn-fab:hover {
  filter: brightness(1.05);
}

/* Set cards */
.set-cards {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin: 10px 0 14px 0;
}

.set-card {
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.04);
  border-radius: 12px;
  padding: 10px 12px;
  cursor: pointer;
  transition: transform .08s ease, background .12s ease, border-color .12s ease;
  min-height: 44px;
}

.set-card:hover {
  transform: translateY(-1px);
  background: rgba(40,140,255,.10);
  border-color: rgba(40,140,255,.45);
}

.set-card.active {
  background: rgba(40,140,255,.18);
  border-color: rgba(40,140,255,.75);
}

.set-card .row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

.set-card .name {
  font-weight: 700;
}

.set-card .meta {
  opacity: .8;
  font-size: 12px;
  margin-top: 4px;
}

/* Info modal */
.info-btn {
  margin-left: 10px;
  padding: 6px 10px;
  border-radius: 10px;
  font-size: 14px;
  line-height: 14px;
  opacity: .85;
}

.info-btn:hover {
  opacity: 1;
}

.modal.hidden {
  display: none;
}

.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.55);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.modal-box {
  width: min(560px, 92vw);
  background: rgba(16,22,32,.98);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 14px;
  padding: 14px;
  box-shadow: 0 20px 80px rgba(0,0,0,.55);
}

.modal-title {
  font-weight: 800;
  margin-bottom: 10px;
}

.modal-pre {
  white-space: pre-wrap;
  word-break: break-word;
  background: rgba(255,255,255,.04);
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 12px;
  padding: 10px;
  font-size: 12px;
  max-height: 45vh;
  overflow: auto;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  margin-top: 10px;
}

.gig-banner {
  display: none !important;
}

/* Status indicator for offline mode */
.offline-indicator {
  position: fixed;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(34,197,94,.2);
  border: 1px solid rgba(34,197,94,.4);
  color: #22c55e;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 11px;
  font-weight: 700;
  z-index: 9998;
  display: none;
}

.offline-indicator.show {
  display: block;
}

/* Toast notification */
.toast {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(10,16,24,.95);
  border: 1px solid var(--accent2);
  color: var(--text);
  padding: 12px 18px;
  border-radius: 12px;
  font-size: 13px;
  font-weight: 700;
  box-shadow: 0 10px 30px rgba(0,0,0,.4);
  z-index: 9999;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

.toast.show {
  opacity: 1;
}

/* Responsive iPad optimizations */
@media (max-width: 1024px) {
  #sidebar {
    position: fixed;
    left: 0;
    transform: translateX(-100%);
    height: 100vh;
    box-shadow: 2px 0 10px rgba(0,0,0,0.3);
  }

  #sidebar.open {
    transform: translateX(0);
  }

  #stage {
    width: 100vw;
  }

  .btn-fab {
    width: 50px;
    height: 50px;
    font-size: 18px;
  }
}

@media (orientation: landscape) and (max-width: 1024px) {
  .stage-bar {
    height: 50px;
    font-size: 14px;
  }

  .title-line {
    font-size: 16px;
  }

  #viewer {
    padding: 5px 40px 30px 40px;
  }
}

@media (max-width: 768px) {
  .stage-bar {
    padding: 0 10px;
    height: 55px;
  }

  .title-line {
    font-size: 14px;
  }

  .artist-inline {
    font-size: 12px;
  }

  .btn, .btn-nav {
    padding: 8px 10px;
    font-size: 12px;
  }
}
</style>
</head>
<body>

<div id="sidebar">
  <div class="sidebar-header">
    <select class="btn" id="userProfile" style="background:var(--ui-accent)">
      <option value="Adam">Profile: Adam</option>
      <option value="Pete">Profile: Pete</option>
    </select>

    <div class="set-cards" id="setCards"></div>

    <button class="btn" onclick="document.getElementById('gigInput').click()">üìÇ LOAD GIG FILE</button>
    <button class="btn" onclick="document.getElementById('folderInput').click()">üìÅ LOAD PRACTICE FOLDER</button>
    <button class="btn" onclick="clearStoredGig()" style="background: rgba(225,29,72,.2); border-color: rgba(225,29,72,.4);">üóëÔ∏è CLEAR STORED GIG</button>

    <input id="gigInput" onchange="importGig(this)" style="display:none" type="file">
    <input directory id="folderInput" multiple onchange="importFolder(this)" style="display:none" type="file" webkitdirectory>

    <div style="font-size: 10px; color: var(--muted); margin-top: 10px; text-align: center;" id="storageStatus">
      No gig loaded
    </div>
  </div>
  <div id="setlistItems"></div>
</div>

<div id="stage">
  <div class="stage-bar">
    <button class="btn" onclick="toggleSidebar()">‚ò∞ MENU</button>

    <div style="display:flex; align-items:center; gap:10px">
      <button class="btn-nav" onclick="changeSong(-1)">‚óÄ PREV</button>

      <div style="text-align:center; min-width: 220px">
        <div class="title-line">
          <span id="headTitle">---</span>
          <span class="artist-inline" id="headArtist"></span>
          <button class="btn info-btn" id="infoBtn" type="button">‚ÑπÔ∏è</button>
        </div>
        <div class="meta-badges" id="metaContainer"></div>
        <div class="gig-banner" id="gigBanner"></div>
      </div>

      <button class="btn-nav" onclick="changeSong(1)">NEXT ‚ñ∂</button>
    </div>

    <button class="btn" onclick="toggleOptions()">‚öôÔ∏è VIEW</button>
  </div>

  <div id="viewer"></div>

  <div id="viewOptions">
    <div class="opt-row">
      <button class="btn" onclick="toggleThemeMode()" style="width:100%; background:#444">üí° SWAP LIGHT/DARK</button>
    </div>
    <div class="opt-row">
      <label>Size</label>
      <input id="slSize" max="80" min="14" oninput="updateUI()" type="range">
    </div>
    <div class="opt-row">
      <label>Spacing</label>
      <input id="slLine" max="2.5" min="0.8" oninput="updateUI()" step="0.1" type="range">
    </div>
    <div class="opt-row">
      <label>Background</label>
      <input id="cpBg" onchange="updateUI()" type="color">
    </div>
    <div class="opt-row">
      <label>Chords</label>
      <input id="cpCho" onchange="updateUI()" type="color">
    </div>
    <div class="opt-row">
      <label>Sections</label>
      <input id="cpSec" onchange="updateUI()" type="color">
    </div>
    <div class="opt-row">
      <label>Chorus</label>
      <input id="cpChr" onchange="updateUI()" type="color">
    </div>
    <button class="btn" onclick="toggleOptions()" style="width:100%; margin-top:10px">CLOSE</button>
  </div>

  <button class="btn-fab" onclick="jumpTo('start')" style="bottom: 90px">‚Üë</button>
  <button class="btn-fab" onclick="jumpTo('end')" style="bottom: 20px">‚Üì</button>
</div>

<div class="modal hidden" id="infoModal">
  <div class="modal-box">
    <div class="modal-title">Sheet info</div>
    <pre class="modal-pre" id="infoText"></pre>
    <div class="modal-actions">
      <button class="btn" id="infoClose" type="button">Close</button>
    </div>
  </div>
</div>

<div class="offline-indicator" id="offlineIndicator">üì° OFFLINE MODE</div>
<div class="toast" id="toast"></div>

<script>
// ============================================
// IndexedDB Persistence Layer
// ============================================
let db = null;

async function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('ChordProStudio', 1);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      db = request.result;
      resolve(db);
    };

    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('gigs')) {
        db.createObjectStore('gigs');
      }
      if (!db.objectStoreNames.contains('settings')) {
        db.createObjectStore('settings');
      }
    };
  });
}

async function saveGigToStorage(gigData, gigName) {
  if (!db) await initDB();

  return new Promise((resolve, reject) => {
    const tx = db.transaction(['gigs', 'settings'], 'readwrite');

    tx.objectStore('gigs').put(gigData, 'current-gig');
    tx.objectStore('settings').put({
      name: gigName,
      timestamp: Date.now(),
      persona: getActivePersona()
    }, 'metadata');

    tx.oncomplete = () => {
      updateStorageStatus(gigName);
      showToast('‚úÖ Gig saved for offline use');
      resolve();
    };
    tx.onerror = () => reject(tx.error);
  });
}

async function loadGigFromStorage() {
  if (!db) await initDB();

  return new Promise((resolve, reject) => {
    const tx = db.transaction(['gigs', 'settings'], 'readonly');
    let gigData = null;
    let metadata = null;

    const gigRequest = tx.objectStore('gigs').get('current-gig');
    gigRequest.onsuccess = () => { gigData = gigRequest.result; };

    const metaRequest = tx.objectStore('settings').get('metadata');
    metaRequest.onsuccess = () => { metadata = metaRequest.result; };

    tx.oncomplete = () => resolve({ gigData, metadata });
    tx.onerror = () => reject(tx.error);
  });
}

async function clearStoredGig() {
  if (!confirm('Clear stored gig? You will need to reload it.')) return;

  if (!db) await initDB();

  const tx = db.transaction(['gigs', 'settings'], 'readwrite');
  tx.objectStore('gigs').delete('current-gig');
  tx.objectStore('settings').delete('metadata');

  tx.oncomplete = () => {
    updateStorageStatus(null);
    showToast('üóëÔ∏è Stored gig cleared');
    activeSongs = [];
    gigSets = [];
    window.gigPackV2 = null;
    window.gigPackV1 = null;
    renderList([]);
    document.getElementById('headTitle').innerText = '---';
    document.getElementById('headArtist').innerText = '';
    document.getElementById('viewer').innerHTML = '';
    updateSetSelector();
  };
}

function updateStorageStatus(gigName) {
  const el = document.getElementById('storageStatus');
  if (!el) return;

  if (gigName) {
    el.innerHTML = `‚úÖ Stored: <b>${escapeHtml(gigName)}</b>`;
    el.style.color = '#22c55e';
  } else {
    el.innerHTML = 'No gig loaded';
    el.style.color = 'var(--muted)';
  }
}

// ============================================
// Touch Gesture Handlers
// ============================================
let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;

function handleTouchStart(e) {
  touchStartX = e.changedTouches[0].screenX;
  touchStartY = e.changedTouches[0].screenY;
}

function handleTouchEnd(e) {
  touchEndX = e.changedTouches[0].screenX;
  touchEndY = e.changedTouches[0].screenY;
  handleSwipeGesture();
}

function handleSwipeGesture() {
  const deltaX = touchEndX - touchStartX;
  const deltaY = touchEndY - touchStartY;
  const threshold = 100;

  // Only trigger if horizontal swipe is dominant
  if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > threshold) {
    if (deltaX < 0) {
      changeSong(1); // Swipe left = next
    } else {
      changeSong(-1); // Swipe right = previous
    }
  }
}

function handleTapNavigation(e) {
  const clickX = e.clientX;
  const width = window.innerWidth;
  const clickY = e.clientY;
  const height = window.innerHeight;

  // Ignore taps in top bar area
  if (clickY < 100) return;

  // Left edge tap = previous
  if (clickX < width * 0.15) {
    changeSong(-1);
  } 
  // Right edge tap = next
  else if (clickX > width * 0.85) {
    changeSong(1);
  }
}

// ============================================
// Keyboard Shortcuts (Desktop)
// ============================================
document.addEventListener('keydown', (e) => {
  // Ignore if typing in input field
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

  switch(e.key) {
    case 'ArrowLeft':
    case 'ArrowUp':
      e.preventDefault();
      changeSong(-1);
      break;
    case 'ArrowRight':
    case 'ArrowDown':
    case ' ':
      e.preventDefault();
      changeSong(1);
      break;
    case 'Home':
      e.preventDefault();
      jumpTo('start');
      break;
    case 'End':
      e.preventDefault();
      jumpTo('end');
      break;
    case 'm':
    case 'M':
      toggleSidebar();
      break;
    case 'Escape':
      const sidebar = document.getElementById('sidebar');
      if (sidebar.classList.contains('open')) {
        toggleSidebar();
      }
      const opts = document.getElementById('viewOptions');
      if (opts.style.display === 'block') {
        toggleOptions();
      }
      break;
  }
});

// ============================================
// Core Functions (Original + Modified)
// ============================================
function getActivePersona() {
  const el = document.getElementById('userProfile');
  const raw = el && typeof el.value !== 'undefined' ? el.value : '';
  return String(raw || 'Adam').trim() || 'Adam';
}

function escapeHtml(str) {
  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

function durationToSeconds(d) {
  if (d == null) return 0;
  if (typeof d === 'number' && isFinite(d)) return Math.max(0, Math.floor(d));

  const s = String(d).trim();
  if (!s) return 0;
  if (/^\d+$/.test(s)) return parseInt(s, 10) || 0;

  const parts = s.split(':').map(p => p.trim()).filter(Boolean);
  if (!parts.length) return 0;

  const nums = parts.map(p => parseInt(p, 10));
  if (nums.some(n => isNaN(n))) return 0;

  if (nums.length === 2) return nums[0]*60 + nums[1];
  if (nums.length === 3) return nums[0]*3600 + nums[1]*60 + nums[2];
  return 0;
}

function formatTime(totalSeconds) {
  const sec = Math.max(0, Math.floor(totalSeconds || 0));
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = sec % 60;
  if (h > 0) return `${h}h ${m}m`;
  return `${m}:${String(s).padStart(2, '0')}`;
}

function normalizePersonaName(s) {
  return s
    .toString()
    .trim()
    .toLowerCase()
    .replace(/\(.*?\)/g, '')
    .replace(/version/g, '')
    .replace(/[^a-z]/g, '')
    .replace(/\s+/g, '')
    .trim();
}

function firstToken(s) {
  const n = normalizePersonaName(s);
  return n.split(' ')[0];
}

function chooseUidForPersona(versionsMap, persona) {
  const p = firstToken(persona);
  const entries = Object.entries(versionsMap);
  if (!entries.length) return null;

  for (const [name, uid] of entries) {
    if (normalizePersonaName(name) === normalizePersonaName(persona)) return uid;
  }

  for (const [name, uid] of entries) {
    if (firstToken(name) === p && p) return uid;
  }

  return entries[0][1];
}

let activeSongs = [];
let gigSets = [];
let activeSetIndex = 0;

function setActiveSet(idx) {
  idx = Number(idx) || 0;
  if (!gigSets.length) {
    activeSetIndex = 0;
    activeSongs = [];
    return;
  }

  activeSetIndex = Math.max(0, Math.min(idx, gigSets.length - 1));
  const setObj = gigSets[activeSetIndex];
  activeSongs = (setObj && Array.isArray(setObj.songs)) ? setObj.songs.slice() : [];
  activeSongs.preserveOrder = true;
  currentIdx = 0;
}

function updateSetSelector() {
  const cards = document.getElementById('setCards');
  if (!cards) return;

  cards.innerHTML = '';

  if (!gigSets || !gigSets.length) {
    const empty = document.createElement('div');
    empty.className = 'set-card';
    empty.style.opacity = '0.75';
    empty.innerHTML = '<div class="row"><div class="name">No sets loaded</div></div><div class="meta">Load a gig file to see sets.</div>';
    cards.appendChild(empty);
    return;
  }

  gigSets.forEach((s, i) => {
    const totalSec = (s.songs || []).reduce((acc, song) => acc + durationToSeconds(song.duration), 0);
    const count = (s.songs || []).length;

    const card = document.createElement('div');
    card.className = 'set-card' + (i === activeSetIndex ? ' active' : '');
    card.innerHTML = `
      <div class="row">
        <div class="name">${escapeHtml(s.name || `Set ${i+1}`)}</div>
        <div class="name" style="font-weight:600; opacity:.85; font-size:12px">${formatTime(totalSec)}</div>
      </div>
      <div class="meta">${count} song${count !== 1 ? 's' : ''}</div>
    `;

    card.onclick = () => {
      setActiveSet(i);
      processAndRender();
    };

    cards.appendChild(card);
  });
}

window.gigPackV2 = null;
window.gigPackV1 = null;
let currentIdx = 0;
let themeMode = 'dark';

function loadUserConfig() {
  const user = document.getElementById('userProfile').value;
  const key = `viewerprefs_${user}_${themeMode}`;

  const def = themeMode === 'dark' 
    ? { bg: '#000000', cho: '#00ffff', sec: '#ffff00', chr: '#ff6b6b', size: 24, line: 1.4 }
    : { bg: '#ffffff', cho: '#0056b3', sec: '#d00000', chr: '#b000b0', size: 24, line: 1.4 };

  const config = JSON.parse(localStorage.getItem(key) || 'null') || def;

  document.getElementById('cpBg').value = config.bg;
  document.getElementById('cpCho').value = config.cho;
  document.getElementById('cpSec').value = config.sec;
  document.getElementById('cpChr').value = config.chr;
  document.getElementById('slSize').value = config.size;
  document.getElementById('slLine').value = config.line;

  applyStyles(config);

  if (activeSongs.length > 0) {
    processAndRender();
  }
}

function toggleThemeMode() {
  themeMode = themeMode === 'dark' ? 'light' : 'dark';
  loadUserConfig();
}

function updateUI() {
  const user = document.getElementById('userProfile').value;
  const config = {
    bg: document.getElementById('cpBg').value,
    cho: document.getElementById('cpCho').value,
    sec: document.getElementById('cpSec').value,
    chr: document.getElementById('cpChr').value,
    size: document.getElementById('slSize').value,
    line: document.getElementById('slLine').value
  };

  localStorage.setItem(`viewerprefs_${user}_${themeMode}`, JSON.stringify(config));
  applyStyles(config);
}

function applyStyles(c) {
  const root = document.documentElement;
  root.style.setProperty('--ipad-bg', c.bg);
  root.style.setProperty('--chord-clr', c.cho);
  root.style.setProperty('--section-clr', c.sec);
  root.style.setProperty('--chorus-clr', c.chr);
  root.style.setProperty('--font-size', c.size + 'px');
  root.style.setProperty('--line-height', c.line);

  const hex = c.bg.replace('#', '');
  const r = parseInt(hex.substring(0,2), 16);
  const g = parseInt(hex.substring(2,4), 16);
  const b = parseInt(hex.substring(4,6), 16);
  root.style.setProperty('--lyric-clr', (r*0.299 + g*0.587 + b*0.114) > 128 ? '#000000' : '#ffffff');
}

function setGigBanner(gig) {
  const el = document.getElementById('gigBanner');
  if (!el) return;
}

async function importGig(input) {
  const reader = new FileReader();

  reader.onload = async (e) => {
    const data = JSON.parse(e.target.result);

    if (data && (data.gigPackPersona === 2 || data.gigPackVersion === 2) && data.songGroups && data.songs && Array.isArray(data.sets)) {
      window.gigPackV2 = data;
      window.gigPackV1 = null;

      activeSongs = [];
      rebuildGigSetsFromGigPackV2(getActivePersona());

      if (typeof setGigBanner === 'function') setGigBanner(data.gig);

      await saveGigToStorage(data, data.gig?.name || 'Unnamed Gig');

      processAndRender();
      return;
    }

    if (data && data.gigPackVersion === 1 && data.songs && Array.isArray(data.sets)) {
      window.gigPackV1 = data;
      window.gigPackV2 = null;

      activeSongs = [];

      data.sets.forEach(set => {
        (set.songUids || []).forEach(uid => {
          const s = data.songs[uid];
          if (s && s.content) {
            activeSongs.push({
              uid,
              content: s.content,
              title: s.title,
              artist: s.artist,
              singer: s.singer,
              persona: s.persona || s.version
            });
          }
        });
      });

      activeSongs.preserveOrder = true;
      gigSets = [{ name: 'Gig', songs: activeSongs.slice() }];
      activeSetIndex = 0;
      updateSetSelector();
      setActiveSet(0);
      setGigBanner(data.gig);

      await saveGigToStorage(data, data.gig?.name || 'Unnamed Gig');

      processAndRender();
      return;
    }

    if (data && Array.isArray(data.sets)) {
      activeSongs = data.sets.flatMap(set => set.songs);
      activeSongs.preserveOrder = true;
      gigSets = [{ name: 'Gig', songs: activeSongs.slice() }];
      activeSetIndex = 0;
      updateSetSelector();
      setActiveSet(0);
      setGigBanner(data.gig);

      await saveGigToStorage(data, 'Legacy Gig');

      processAndRender();
      return;
    }

    setGigBanner(null);
    showToast('‚ùå Unrecognised gig file format');
  };

  reader.readAsText(input.files[0]);
}

async function importFolder(input) {
  activeSongs = [];

  for (let file of input.files) {
    if (file.name.endsWith('.cho')) {
      const text = await file.text();
      activeSongs.push({
        content: text,
        filename: file.name
      });
    }
  }

  processAndRender();
}

function rebuildGigSetsFromGigPackV2(persona) {
  if (!window.gigPackV2) return false;

  const data = window.gigPackV2;
  const p = String(persona || getActivePersona()).trim();

  const nextSets = [];

  (data.sets || []).forEach(set => {
    const songs = [];

    (set.songKeys || []).forEach(key => {
      const g = data.songGroups[key];
      if (!g) return;

      const personas = g.personas || {};
      const chosenUid = chooseUidForPersona(personas, p) || chooseUidForPersona(personas, '');
      const s = chosenUid ? data.songs[chosenUid] : null;

      if (s && s.content) {
        const mDuration = s.duration || String(s.content.match(/\{duration[:\s]*(.*?)\}/i)?.[1] || '');
        const mCapo = s.capo || String(s.content.match(/\{capo[:\s]*(.*?)\}/i)?.[1] || '');
        const mSinger = s.singer || String(s.content.match(/\{singer[:\s]*(.*?)\}/i)?.[1] || '');
        const mPersona = s.persona || s.version || String(s.content.match(/\{persona[:\s]*(.*?)\}/i)?.[1] || '');

        songs.push({
          uid: chosenUid,
          content: s.content,
          title: s.title || g.title,
          artist: s.artist || g.artist,
          singer: mSinger,
          duration: String(mDuration).trim(),
          capo: String(mCapo).trim(),
          persona: String(mPersona).trim()
        });
      }
    });

    nextSets.push({
      name: set.name,
      songKeys: Array.isArray(set.songKeys) ? set.songKeys.slice() : [],
      songs
    });
  });

  gigSets = nextSets;

  const prevName = (gigSets[activeSetIndex] && gigSets[activeSetIndex].name) ? gigSets[activeSetIndex].name : null;
  let nextIndex = 0;

  if (prevName) {
    const found = gigSets.findIndex(s => s.name === prevName);
    if (found >= 0) nextIndex = found;
  }

  activeSetIndex = Math.max(0, Math.min(nextIndex, Math.max(gigSets.length - 1, 0)));
  updateSetSelector();
  setActiveSet(activeSetIndex);

  return true;
}

function processAndRender() {
  const user = document.getElementById('userProfile').value.toLowerCase();
  const preserveOrder = !!activeSongs.preserveOrder;

  const songMap = new Map();
  const orderKeys = [];

  activeSongs.forEach(s => {
    const content = s.content || '';
    const uid = content.match(/\{uid[:\s]*(.*?)\}/i)?.[1]?.trim() || s.uid;
    const title = content.match(/\{t?itle?[:\s]*(.*?)\}/i)?.[1]?.trim() || s.title || s.filename || 'Untitled';
    const artist = content.match(/\{artist[:\s]*(.*?)\}/i)?.[1]?.trim() || s.artist || 'Unknown Artist';
    const singer = content.match(/\{singer[:\s]*(.*?)\}/i)?.[1]?.trim() || s.singer;
    const persona = content.match(/\{persona[:\s]*(.*?)\}/i)?.[1]?.trim() || content.match(/\{p[:\s]*(.*?)\}/i)?.[1]?.trim() || content.match(/\{version[:\s]*(.*?)\}/i)?.[1]?.trim() || s.persona || s.version;
    const capo = content.match(/\{capo[:\s]*(.*?)\}/i)?.[1] || null;

    const key = `${title}||${artist}`;

    if (!songMap.has(key)) {
      songMap.set(key, { uid, title, artist, singer, persona, capo, content });
      orderKeys.push(key);
    } else {
      const existing = songMap.get(key);
      const existingMatches = firstToken(existing.persona) === firstToken(user);
      const currentMatches = firstToken(persona) === firstToken(user);

      if (!existingMatches && currentMatches) {
        songMap.set(key, { uid, title, artist, singer, persona, capo, content });
      }
    }
  });

  const list = preserveOrder 
    ? orderKeys.map(k => songMap.get(k)).filter(Boolean)
    : Array.from(songMap.values()).sort((a,b) => a.title.localeCompare(b.title));

  activeSongs.processed = list;
  currentIdx = Math.min(currentIdx, Math.max(0, list.length - 1));

  renderList(list);

  if (list.length > 0) {
    displaySong(list[currentIdx], currentIdx);
  }
}

function renderList(songs) {
  const cont = document.getElementById('setlistItems');
  cont.innerHTML = '';

  songs.forEach((s, i) => {
    const card = document.createElement('div');
    card.className = 'song-card' + (currentIdx === i ? ' active' : '');

    const singerTxt = s.singer || s.content.match(/\{singer[:\s]*(.*?)\}/i)?.[1]?.trim() || '';

    card.innerHTML = `<b>${s.title}</b><small>${s.artist}${singerTxt ? ' ‚Ä¢ ' + singerTxt : ''}</small>`;

    card.onclick = () => {
      currentIdx = i;
      displaySong(s, i);
      renderList(songs);
    };

    cont.appendChild(card);
  });
}

function displaySong(s, idx) {
  document.getElementById('headTitle').innerText = s.title || 'Untitled';

  const artistEl = document.getElementById('headArtist');
  artistEl.innerText = s.artist && String(s.artist).trim() ? `‚Äî ${s.artist}` : '';

  const meta = document.getElementById('metaContainer');
  meta.innerHTML = s.capo ? `<span class="badge">CAPO ${s.capo}</span>` : '';

  const content = s.content || '';
  const uid = s.uid || content.match(/\{uid[:\s]*(.*?)\}/i)?.[1]?.trim() || '';
  const persona = s.persona || content.match(/\{persona[:\s]*(.*?)\}/i)?.[1]?.trim() || content.match(/\{p[:\s]*(.*?)\}/i)?.[1]?.trim() || content.match(/\{version[:\s]*(.*?)\}/i)?.[1]?.trim() || '';
  const title = s.title || content.match(/\{t?itle?[:\s]*(.*?)\}/i)?.[1]?.trim() || 'Untitled';
  const artist = s.artist || content.match(/\{artist[:\s]*(.*?)\}/i)?.[1]?.trim() || '';
  const uidShort = uid ? uid.slice(0, 8) : 'no-uid';
  const filename = `${title}${artist ? ' - ' + artist : ''}${persona ? ' (' + persona + ')' : ''}.cho`;

  const banner = document.getElementById('gigBanner');
  if (banner) banner.textContent = `üìÑ ${filename} ‚Ä¢ ${uidShort}`;

  const singer = s.singer || content.match(/\{singer[:\s]*(.*?)\}/i)?.[1]?.trim() || '';
  const duration = s.duration || content.match(/\{duration[:\s]*(.*?)\}/i)?.[1]?.trim() || '';
  const capoVal = s.capo || content.match(/\{capo[:\s]*(.*?)\}/i)?.[1]?.trim() || '';

  window.currentSheetInfo = {
    filename,
    uid: uid || '',
    uidShort,
    persona: persona || '',
    singer: singer || '',
    duration: duration || '',
    capo: capoVal || ''
  };

  renderChordPro(content);
}

function changeSong(dir) {
  let newIdx = currentIdx + dir;

  if (newIdx < 0) newIdx = activeSongs.processed.length - 1;
  if (newIdx >= activeSongs.processed.length) newIdx = 0;

  currentIdx = newIdx;
  displaySong(activeSongs.processed[currentIdx], currentIdx);
  renderList(activeSongs.processed);
}

function renderChordPro(content) {
  let finalHtml = '';
  let inChorus = false;

  const lines = content.split('\n').filter((line, index, arr) => {
    return !(line.trim() === '' && arr[index - 1]?.trim() === '');
  });

  lines.forEach(line => {
    let p = line.trim();

    const commentMatch = p.match(/\{c?omment[:\s]*(.*?)\}/i);
    if (commentMatch) {
      if (commentMatch[1].toLowerCase() === 'chorus') {
        if (inChorus) finalHtml += '</div>';
        inChorus = true;
        finalHtml += '<div class="chorus-container"><span class="p-section">CHORUS</span>\n';
        return;
      }

      if (p === commentMatch[1].toLowerCase() && commentMatch[1].toLowerCase() !== 'chorus') {
        if (inChorus) {
          finalHtml += '</div>';
          inChorus = false;
        }
      }

      if (commentMatch[1].toLowerCase() !== 'chorus') {
        finalHtml += `<span class="p-section">${commentMatch[1]}</span>\n`;
        return;
      }
    }

    if (p.startsWith('{')) return;

    let styledLine = p.replace(/\[([^\]]+)\]/g, '<span class="p-chord">$1</span>');
    finalHtml += styledLine + '\n';
  });

  if (inChorus) finalHtml += '</div>';

  document.getElementById('viewer').innerHTML = finalHtml;
  document.getElementById('viewer').scrollTop = 0;
}

function jumpTo(dest) {
  const v = document.getElementById('viewer');
  v.scrollTo({
    top: dest === 'end' ? v.scrollHeight : 0,
    behavior: 'smooth'
  });
}

function toggleSidebar() {
  const s = document.getElementById('sidebar');
  s.classList.toggle('open');
}

function toggleOptions() {
  const p = document.getElementById('viewOptions');
  p.style.display = p.style.display === 'block' ? 'none' : 'block';
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  clearTimeout(t.timer);
  t.timer = setTimeout(() => t.classList.remove('show'), 2500);
}

// Persona dropdown change handler
function wirePersonaChange() {
  const el = document.getElementById('userProfile');
  if (el && !el.personaBound) {
    el.personaBound = true;
    el.addEventListener('change', () => {
      loadUserConfig();
      if (window.gigPackV2) {
        rebuildGigSetsFromGigPackV2(getActivePersona());
        processAndRender();
      }
    });
  }
}

// Sheet info modal
const infoBtn = document.getElementById('infoBtn');
const infoModal = document.getElementById('infoModal');
const infoText = document.getElementById('infoText');
const infoClose = document.getElementById('infoClose');

function openInfo() {
  if (!infoModal || !infoText) return;

  const i = window.currentSheetInfo || {};
  const lines = [
    `Filename: ${i.filename || 'unknown'}`,
    `UID: ${i.uid || ''}`,
    `Persona: ${i.persona || ''}`,
    `Singer: ${i.singer || ''}`,
    `Duration: ${i.duration || ''}`,
    `Capo: ${i.capo || ''}`
  ].filter(Boolean);

  infoText.textContent = lines.join('\n');
  infoModal.classList.remove('hidden');
}

function closeInfo() {
  if (!infoModal) return;
  infoModal.classList.add('hidden');
}

if (infoBtn && !infoBtn.bound) {
  infoBtn.bound = true;
  infoBtn.addEventListener('click', openInfo);
}

if (infoClose && !infoClose.bound) {
  infoClose.bound = true;
  infoClose.addEventListener('click', closeInfo);
}

if (infoModal && !infoModal.bound) {
  infoModal.bound = true;
  infoModal.addEventListener('click', (e) => {
    if (e.target === infoModal) closeInfo();
  });
}

// Check online/offline status
window.addEventListener('online', () => {
  document.getElementById('offlineIndicator').classList.remove('show');
});

window.addEventListener('offline', () => {
  document.getElementById('offlineIndicator').classList.add('show');
});

if (!navigator.onLine) {
  document.getElementById('offlineIndicator').classList.add('show');
}

// Initialize
async function init() {
  await initDB();

  const stored = await loadGigFromStorage();

  if (stored.gigData && stored.metadata) {
    const data = stored.gigData;

    if (data.gigPackPersona === 2 || data.gigPackVersion === 2) {
      window.gigPackV2 = data;
      rebuildGigSetsFromGigPackV2(stored.metadata.persona || getActivePersona());
    } else if (data.gigPackVersion === 1) {
      window.gigPackV1 = data;
      activeSongs = [];
      data.sets?.forEach(set => {
        (set.songUids || []).forEach(uid => {
          const s = data.songs[uid];
          if (s && s.content) {
            activeSongs.push({
              uid,
              content: s.content,
              title: s.title,
              artist: s.artist,
              singer: s.singer,
              persona: s.persona || s.version
            });
          }
        });
      });
      activeSongs.preserveOrder = true;
      gigSets = [{ name: 'Gig', songs: activeSongs.slice() }];
      activeSetIndex = 0;
      updateSetSelector();
      setActiveSet(0);
    }

    updateStorageStatus(stored.metadata.name);
    processAndRender();
    showToast('‚úÖ Loaded stored gig');
  }

  wirePersonaChange();
  loadUserConfig();

  // Wire touch gestures
  const viewer = document.getElementById('viewer');
  if (viewer) {
    viewer.addEventListener('touchstart', handleTouchStart, { passive: true });
    viewer.addEventListener('touchend', handleTouchEnd, { passive: true });
    viewer.addEventListener('click', handleTapNavigation);
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
</script>

</body>
</html>
