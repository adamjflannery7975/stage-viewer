<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0b0f14">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icon-192.png">
<title>ChordPro Stage Viewer v3.11.1</title>
<style>
/* =========================
   GLOBAL THEME BLOCK (Shared)
   - Used by: ChordPro Edit, Gig Builder, Stage Viewer, Catalog Manager
   - Safe to edit: colours, radii, shadows, fonts
   - Do NOT change variable names (other CSS relies on them)
   ========================= */
:root{
  --bg:#0b0f14;
  --panel:#0f1620;
  --panel2:#0c121b;
  --text:#e8eef7;
  --muted:#9fb0c7;
  --line:#223144;
  --accent:#00bcd4;
  --accent2:#3b82f6;
  --danger:#e11d48;
  --ok:#22c55e;
  --shadow: 0 10px 30px rgba(0,0,0,.35);
  --radius: 12px;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
}

/* Stage Viewer UI tokens (mapped to shared theme) */
:root{
  --ui-bg: var(--panel);
  --ui-card: var(--panel2);
  --ui-accent: var(--accent2);
  --ui-text: var(--text);

  /* Sheet rendering palette (themeable) */
  --ipad-bg: #000;
  --chord-clr: #00ffff;
  --section-clr: #ffff00;
  --chorus-clr: #ff6b6b;
  --lyric-clr: #fff;

  --font-size: 24px;
  --line-height: 1.4;
}

*{ box-sizing:border-box; }
body{
  margin:0;
  font-family:var(--sans);
  background:linear-gradient(180deg, #07101a 0%, #05070b 100%);
  color:var(--text);
  display:flex;
  height:100vh;
  overflow:hidden;
}
a{ color: var(--accent2); }
button, select, input, textarea{ font-family:inherit; }

/* Sidebar */
#sidebar{
  width:320px;
  background:rgba(10,16,24,.92);
  backdrop-filter: blur(8px);
  border-right:1px solid var(--line);
  display:flex;
  flex-direction:column;
  z-index:10;
}
.sidebar-header{
  padding:14px;
  border-bottom:1px solid var(--line);
  display:flex;
  flex-direction:column;
  gap:10px;
}
#setlistItems{ flex:1; overflow-y:auto; padding:12px; }

/* Inputs */
select, input[type="text"]{
  width:100%;
  appearance:none;
  border:1px solid #2a3a50;
  background:linear-gradient(180deg,#1b2a3d 0%, #152234 100%);
  color:var(--text);
  padding:9px 10px;
  border-radius:10px;
  font-weight:700;
  font-size:13px;
  outline:none;
}
select:focus, input[type="text"]:focus{ box-shadow:0 0 0 3px rgba(59,130,246,.25); }

/* Song cards */
.song-card{
  background: linear-gradient(180deg, rgba(15,22,32,.9) 0%, rgba(12,18,27,.9) 100%);
  border:1px solid var(--line);
  border-radius:var(--radius);
  padding:12px;
  margin-bottom:10px;
  cursor:pointer;
  box-shadow:0 6px 18px rgba(0,0,0,.25);
}
.song-card:hover{ border-color:#2f4766; }
.song-card.active{
  border-color: var(--accent2);
  box-shadow: 0 0 0 3px rgba(59,130,246,.22), 0 10px 26px rgba(0,0,0,.35);
}
.song-card b{ display:block; font-size:14px; color:var(--text); }
.song-card small{ display:block; font-size:11px; color:var(--muted); margin-top:4px; }

/* Stage */
#stage{ flex:1; display:flex; flex-direction:column; position:relative; }
.stage-bar{
  height:65px;
  background:rgba(10,16,24,.92);
  backdrop-filter: blur(8px);
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:0 16px;
  border-bottom:1px solid var(--line);
  flex-shrink:0;
}
.title-line{ font-weight:800; font-size:18px; color:var(--text); }
.artist-inline{ font-weight:600; opacity:.7; margin-left:10px; font-size:14px; color:var(--muted); }

.meta-badges{ display:flex; gap:8px; margin-top:4px; justify-content:center; }
.badge{
  background: linear-gradient(180deg,#2563eb 0%, #1d4ed8 100%);
  border:1px solid #2a3a50;
  color:white;
  padding:2px 8px;
  border-radius:6px;
  font-size:10px;
  font-weight:800;
  text-transform:uppercase;
}

/* Viewer area */
#viewer{
  flex:1;
  overflow-y:scroll;
  padding:10px 10% 40px 10%;
  white-space:pre-wrap;
  font-size:var(--font-size);
  line-height:var(--line-height);
  color:var(--lyric-clr);
  scroll-behavior:smooth;
  background: var(--ipad-bg);
}
.p-chord{ color: var(--chord-clr); font-weight:800; position:relative; top:-0.2em; }
.p-section{ color: var(--section-clr); font-weight:800; display:block; margin-top:0.6em; border-bottom:none !important; }
.chorus-container{ border-left:4px solid var(--chorus-clr); padding-left:20px; margin:10px 0; color:var(--chorus-clr) !important; }

/* Options panel */
#viewOptions{
  position:absolute;
  top:75px;
  right:20px;
  background:rgba(15,22,32,.96);
  border:1px solid var(--line);
  padding:18px;
  border-radius:14px;
  display:none;
  width:280px;
  z-index:1000;
  box-shadow: var(--shadow);
}
.opt-row{ display:flex; justify-content:space-between; align-items:center; margin-bottom:14px; font-size:12px; color:var(--text); }
.opt-row label{ flex:1; color:var(--muted); font-weight:700; }
.opt-row input[type="range"]{ flex:1.5; margin:0 10px; accent-color: var(--accent2); }

/* Buttons (match Gig Builder) */
.btn, .btn-nav{
  appearance:none;
  border:1px solid #2a3a50;
  background:linear-gradient(180deg,#1b2a3d 0%, #152234 100%);
  color:var(--text);
  padding:9px 12px;
  border-radius:10px;
  cursor:pointer;
  font-weight:800;
  font-size:13px;
  box-shadow:0 8px 20px rgba(0,0,0,.25);
  display:inline-flex;
  align-items:center;
  gap:8px;
  user-select:none;
}
.btn:hover, .btn-nav:hover{ filter:brightness(1.05); border-color:#3b82f6; }
.btn:active, .btn-nav:active{ transform: translateY(1px); }

.btn-fab{
  width:55px;
  height:55px;
  border-radius:14px;
  background: linear-gradient(180deg,#2563eb 0%, #1d4ed8 100%);
  border:1px solid #2a3a50;
  color:white;
  font-size:20px;
  position:fixed;
  right:20px;
  cursor:pointer;
  z-index:900;
  box-shadow:0 14px 30px rgba(0,0,0,.35);
  opacity:.92;
}
.btn-fab:hover{ filter:brightness(1.05); }

/* Misc */
.gig-banner{
  font-size:12px;
  opacity:.85;
  margin-top:2px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}


/* --- Stage Viewer: Set cards + info modal (UI only) --- */
.set-cards{display:flex;flex-direction:column;gap:10px;margin:10px 0 14px 0;}
.set-card{border:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.04);border-radius:12px;padding:10px 12px;cursor:pointer;transition:transform .08s ease, background .12s ease, border-color .12s ease;}
.set-card:hover{transform:translateY(-1px);background:rgba(40,140,255,.10);border-color:rgba(40,140,255,.45);}
.set-card.active{background:rgba(40,140,255,.18);border-color:rgba(40,140,255,.75);}
.set-card .row{display:flex;align-items:center;justify-content:space-between;gap:10px;}
.set-card .name{font-weight:700;}
.set-card .meta{opacity:.8;font-size:12px;margin-top:4px;}
.info-btn{margin-left:10px;padding:6px 10px;border-radius:10px;font-size:14px;line-height:14px;opacity:.85;}
.info-btn:hover{opacity:1;}
.modal.hidden{display:none;}
.modal{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:9999;}
.modal-box{width:min(560px,92vw);background:rgba(16,22,32,.98);border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:14px;box-shadow:0 20px 80px rgba(0,0,0,.55);}
.modal-title{font-weight:800;margin-bottom:10px;}
.modal-pre{white-space:pre-wrap;word-break:break-word;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px;font-size:12px;max-height:45vh;overflow:auto;}
.modal-actions{display:flex;justify-content:flex-end;margin-top:10px;}

/* Global style override: hide filename banner under title */
.gig-banner{display:none !important;}
</style>
</head>
<body>
<div id="sidebar">
<div class="sidebar-header">
<select class="btn" id="userProfile" onchange="loadUserConfig()" style="background:var(--ui-accent)">
<option value="Adam">Profile: Adam</option>
<option value="Pete">Profile: Pete</option>
</select>
<div class="set-cards" id="setCards"></div>
<button class="btn" onclick="document.getElementById('gigInput').click()">üìÇ LOAD GIG FILE</button>
<button class="btn" onclick="document.getElementById('folderInput').click()">üìÅ LOAD PRACTICE FOLDER</button>
<input id="gigInput" onchange="importGig(this)" style="display:none" type="file"/>
<input directory="" id="folderInput" multiple="" onchange="importFolder(this)" style="display:none" type="file" webkitdirectory=""/>
</div>
<div id="setlistItems"></div>
</div>
<div id="stage">
<div class="stage-bar">
<button class="btn" onclick="toggleSidebar()">‚ò∞ MENU</button>
<div style="display:flex; align-items:center; gap:10px;">
<button class="btn-nav" onclick="changeSong(-1)">¬´ PREV</button>
<div style="text-align:center; min-width: 220px;">
<div class="title-line"><span id="headTitle">---</span><span class="artist-inline" id="headArtist"></span><button class="btn info-btn" id="infoBtn" type="button">‚ÑπÔ∏é</button></div>
<div class="meta-badges" id="metaContainer"></div>
<div class="gig-banner" id="gigBanner"></div>
</div>
<button class="btn-nav" onclick="changeSong(1)">NEXT ¬ª</button>
</div>
<button class="btn" onclick="toggleOptions()">‚öôÔ∏è VIEW</button>
</div>
<div id="viewer"></div>
<div id="viewOptions">
<div class="opt-row"><button class="btn" onclick="toggleThemeMode()" style="width:100%; background:#444;">üåì SWAP LIGHT/DARK</button></div>
<div class="opt-row"><label>Size</label><input id="slSize" max="80" min="14" oninput="updateUI()" type="range"/></div>
<div class="opt-row"><label>Spacing</label><input id="slLine" max="2.5" min="0.8" oninput="updateUI()" step="0.1" type="range"/></div>
<div class="opt-row"><label>Background</label><input id="cpBg" onchange="updateUI()" type="color"/></div>
<div class="opt-row"><label>Chords</label><input id="cpCho" onchange="updateUI()" type="color"/></div>
<div class="opt-row"><label>Sections</label><input id="cpSec" onchange="updateUI()" type="color"/></div>
<div class="opt-row"><label>Chorus</label><input id="cpChr" onchange="updateUI()" type="color"/></div>
<button class="btn" onclick="toggleOptions()" style="width:100%; margin-top:10px;">CLOSE</button>
</div>
<button class="btn-fab" onclick="jumpTo('start')" style="bottom: 90px;">‚ñ≤</button>
<button class="btn-fab" onclick="jumpTo('end')" style="bottom: 20px;">‚ñº</button>
</div>
<div class="modal hidden" id="infoModal"><div class="modal-box"><div class="modal-title">Sheet info</div><pre class="modal-pre" id="infoText"></pre><div class="modal-actions"><button class="btn" id="infoClose" type="button">Close</button></div></div></div><script>
      function getActivePersona(){
  const el = document.getElementById('userProfile');
  const raw = (el && typeof el.value !== 'undefined') ? el.value : '';
  return String(raw || 'Adam').trim() || 'Adam';
}
      function escapeHtml(str){
        return String(str||'').replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
      }
      function durationToSeconds(d){
        if (d == null) return 0;
        // Accept "M:SS", "MM:SS", "H:MM:SS", or seconds as number/string.
        if (typeof d === 'number' && isFinite(d)) return Math.max(0, Math.floor(d));
        const s = String(d).trim();
        if (!s) return 0;
        if (/^\d+$/.test(s)) return parseInt(s,10) || 0;
        const parts = s.split(':').map(p=>p.trim()).filter(Boolean);
        if (!parts.length) return 0;
        const nums = parts.map(p=>parseInt(p,10));
        if (nums.some(n=>isNaN(n))) return 0;
        if (nums.length === 2) return nums[0]*60 + nums[1];
        if (nums.length === 3) return nums[0]*3600 + nums[1]*60 + nums[2];
        return 0;
      }
      function formatTime(totalSeconds){
        const sec = Math.max(0, Math.floor(totalSeconds||0));
        const h = Math.floor(sec/3600);
        const m = Math.floor((sec%3600)/60);
        const s = sec%60;
        if (h>0) return `${h}h ${m}m`;
        return `${m}m ${String(s).padStart(2,'0')}s`;
      }


        // Persona/version matching helpers
        function normalizePersonaName(s){
            return (s||'')
                .toString()
                .trim()
                .toLowerCase()
                .replace(/\(.*?\)/g,'')         // remove parenthetical
                .replace(/\bversion\b/g,'')     // drop the word 'version'
                .replace(/[^a-z]/g,' ')           // keep letters
                .replace(/\s+/g,' ')
                .trim();
        }
        function firstToken(s){
            const n = normalizePersonaName(s);
            return n.split(' ')[0] || '';
        }
        function chooseUidForPersona(versionsMap, persona){
            const p = firstToken(persona);
            const entries = Object.entries(versionsMap || {});
            if (!entries.length) return null;

            // 1) Exact normalized match
            for (const [name, uid] of entries){
                if (normalizePersonaName(name) === normalizePersonaName(persona)) return uid;
            }
            // 2) First-token match (handles "Pete Version", "Pete (alt)", etc.)
            for (const [name, uid] of entries){
                if (firstToken(name) === p && p) return uid;
            }
            // 3) Fallback: first available
            return entries[0][1];
        }

    let activeSongs = [];


// Sets support (keep the gig pack's set structure instead of flattening it away)
let gigSets = [];          // [{name, songKeys:[], songs:[{...}]}]
let activeSetIndex = 0;

function setActiveSet(idx){
    idx = Number(idx)||0;
    if (!gigSets.length) {
        activeSetIndex = 0;
        activeSongs = [];
        return;
    }
    activeSetIndex = Math.max(0, Math.min(idx, gigSets.length - 1));
    const setObj = gigSets[activeSetIndex];
    activeSongs = (setObj && Array.isArray(setObj.songs)) ? setObj.songs.slice() : [];
    activeSongs.__preserveOrder = true;
    currentIdx = 0;
}

function updateSetSelector() {
        // Replaces legacy <select> with clickable Set cards.
        const cards = document.getElementById('setCards');
        const sel = document.getElementById('setSelector'); // may not exist anymore; keep safe
        if (sel) sel.innerHTML = ''; // no longer used

        if (!cards) return;
        cards.innerHTML = '';

        if (!gigSets || !gigSets.length) {
            const empty = document.createElement('div');
            empty.className = 'set-card';
            empty.style.opacity = '0.75';
            empty.innerHTML = `<div class="row"><div class="name">No sets loaded</div></div><div class="meta">Load a gig file to see sets.</div>`;
            cards.appendChild(empty);
            return;
        }

        gigSets.forEach((s, i) => {
            const totalSec = (s.songs || []).reduce((acc, song) => acc + durationToSeconds(song.duration), 0);
            const count = (s.songs || []).length;
            const card = document.createElement('div');
            card.className = 'set-card' + (i === activeSetIndex ? ' active' : '');
            card.innerHTML = `
              <div class="row">
                <div class="name">${escapeHtml(s.name || ('Set ' + (i+1)))}</div>
                <div class="name" style="font-weight:600; opacity:.85; font-size:12px;">${formatTime(totalSec)}</div>
              </div>
              <div class="meta">${count} song${count===1?'':'s'}</div>
            `;
            card.onclick = () => {
                setActiveSet(i);
                processAndRender();
            };
            cards.appendChild(card);
        });
    }

function onSetChange(){
    const sel = document.getElementById('setSelector');
    const idx = sel ? sel.value : '0';
    setActiveSet(idx);
    processAndRender();
}



// Persist last loaded gig pack so persona changes can re-select sheets
window.__gigPackV2 = null;
window.__gigPackV1 = null;

    let currentIdx = 0;
    let themeMode = localStorage.getItem('viewer_theme') || 'dark';

    
    function applyThemeClass(){
        document.body.classList.toggle('light-theme', themeMode === 'light');
    }

function loadUserConfig() {
        applyThemeClass();
        const user = document.getElementById('userProfile').value;
        const key = `viewer_prefs_${user}_${themeMode}`;
        const def = themeMode === 'dark' ? 
            { bg: '#000000', cho: '#00ffff', sec: '#ffff00', chr: '#ff6b6b', size: 24, line: 1.4 } :
            { bg: '#ffffff', cho: '#0056b3', sec: '#d00000', chr: '#b000b0', size: 24, line: 1.4 };
        
        const config = JSON.parse(localStorage.getItem(key)) || def;
        document.getElementById('cpBg').value = config.bg;
        document.getElementById('cpCho').value = config.cho;
        document.getElementById('cpSec').value = config.sec;
        document.getElementById('cpChr').value = config.chr;
        document.getElementById('slSize').value = config.size;
        document.getElementById('slLine').value = config.line;
        
        applyStyles(config);
        if (activeSongs.length > 0) processAndRender();
    }

    function toggleThemeMode() { themeMode = themeMode === 'dark' ? 'light' : 'dark'; localStorage.setItem('viewer_theme', themeMode); applyThemeClass(); loadUserConfig(); }

    function updateUI() {
        const user = document.getElementById('userProfile').value;
        const config = {
            bg: document.getElementById('cpBg').value,
            cho: document.getElementById('cpCho').value,
            sec: document.getElementById('cpSec').value,
            chr: document.getElementById('cpChr').value,
            size: document.getElementById('slSize').value,
            line: document.getElementById('slLine').value
        };
        localStorage.setItem(`viewer_prefs_${user}_${themeMode}`, JSON.stringify(config));
        applyStyles(config);
    }

    function applyStyles(c) {
        const root = document.documentElement;
        root.style.setProperty('--ipad-bg', c.bg);
        root.style.setProperty('--chord-clr', c.cho);
        root.style.setProperty('--section-clr', c.sec);
        root.style.setProperty('--chorus-clr', c.chr);
        root.style.setProperty('--font-size', c.size + 'px');
        root.style.setProperty('--line-height', c.line);
        const r = parseInt(c.bg.slice(1,3), 16), g = parseInt(c.bg.slice(3,5), 16), b = parseInt(c.bg.slice(5,7), 16);
        root.style.setProperty('--lyric-clr', (r*0.299 + g*0.587 + b*0.114) < 128 ? '#ffffff' : '#000000');
    }

    function setGigBanner(gig) {
        // Keep for compatibility with older gig packs, but the UI banner is now used
        // to show the *actual sheet identity* (filename/version/uid) for testing.
        const el = document.getElementById('gigBanner');
        if (!el) return;
        // Do not overwrite the sheet banner; leave it as-is until a song is displayed.
    }

    function importGig(input) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const data = JSON.parse(e.target.result);

            
            // Offline Gig Pack (v2): { gigPackPersona:2, songGroups:{key:{personas{persona:uid}}}, songs:{uid:{content}}, sets:[{name, songKeys:[]}] }
            if (data && (data.gigPackPersona === 2 || data.gigPackVersion === 2) && data.songGroups && data.songs && Array.isArray(data.sets)) {
                window.__gigPackV2 = data;
                window.__gigPackV1 = null;

                // Build initial playlist using current persona (and allow switching later)
                activeSongs = [];
                rebuildGigSetsFromGigPackV2(getActivePersona());



                if (typeof setGigBanner === 'function') setGigBanner(data.gig);
                processAndRender();
                return;
            }

// Offline Gig Pack (v1): { gigPackVersion:1, songs:{uid:{...}}, sets:[{name, songUids:[]}] }
            if (data && data.gigPackVersion === 1 && data.songs && Array.isArray(data.sets)) {
                window.__gigPackV1 = data;
                window.__gigPackV2 = null;
                activeSongs = [];
                data.sets.forEach(set => {
                    (set.songUids || []).forEach(uid => {
                        const s = data.songs[uid];
                        if (s && s.content) {
                            activeSongs.push({ uid, content: s.content, title: s.title, artist: s.artist, singer: s.singer, persona: s.persona || s.version });
                        }
                    });
                });
                activeSongs.__preserveOrder = true;
                gigSets = [{ name: 'Gig', songs: activeSongs.slice() }];
                activeSetIndex = 0;
                updateSetSelector();
                setActiveSet(0);
                setGigBanner(data.gig);
                processAndRender();
                return;
            }

            // Legacy gig export: { sets:[{songs:[{content,...}]}] }
            if (data && Array.isArray(data.sets)) {
                activeSongs = data.sets.flatMap(set => set.songs || []);
                activeSongs.__preserveOrder = true;
                gigSets = [{ name: 'Gig', songs: activeSongs.slice() }];
                activeSetIndex = 0;
                updateSetSelector();
                setActiveSet(0);
                setGigBanner(data.gig);
                processAndRender();
                return;
            }

            setGigBanner(null);
            alert('Unrecognised gig file format.');
        };
        reader.readAsText(input.files[0]);
    }

    async function importFolder(input) {
        activeSongs = [];
        for (let file of input.files) {
            if (file.name.endsWith('.cho')) {
                const text = await file.text();
                activeSongs.push({ content: text, filename: file.name });
            }
        }
        processAndRender();
    }


function rebuildGigSetsFromGigPackV2(persona){
  // Build gigSets[] from the cached v2 gig pack, choosing the best version per songKey for the selected persona.
  if (!window.__gigPackV2) return false;

  const data = window.__gigPackV2;
  const p = String(persona || getActivePersona() || '').trim();

  const nextSets = [];
  (data.sets || []).forEach(set => {
    const songs = [];
    (set.songKeys || []).forEach(key => {
      const g = (data.songGroups || {})[key];
      if (!g) return;

      const personas = (g.personas || {});
      const chosenUid = chooseUidForPersona(personas, p) || chooseUidForPersona(personas, '');
      const s = chosenUid ? (data.songs || {})[chosenUid] : null;

      if (s && s.content) {
        // Pull key meta from explicit fields first, then fall back to tags in the ChordPro content.
        const mDuration = s.duration || (String(s.content||'').match(/\{duration:\s*([^}]+)\}/i)?.[1] || '');
        const mCapo = s.capo || (String(s.content||'').match(/\{capo:\s*([^}]+)\}/i)?.[1] || '');
        const mSinger = s.singer || (String(s.content||'').match(/\{singer:\s*([^}]+)\}/i)?.[1] || '');
        const mPersona = s.persona || s.version || (String(s.content||'').match(/\{persona:\s*([^}]+)\}/i)?.[1] || '');

        songs.push({
          uid: chosenUid,
          content: s.content,
          title: s.title || g.title || '',
          artist: s.artist || g.artist || '',
          singer: mSinger,
          duration: String(mDuration).trim(),
          capo: String(mCapo).trim(),
          persona: String(mPersona).trim()
        });
      }
    });

    nextSets.push({
      name: set.name || '',
      songKeys: Array.isArray(set.songKeys) ? set.songKeys.slice() : [],
      songs
    });
  });

  gigSets = nextSets;

  // Keep previously selected set if possible (by name), else default to first set.
  const prevName = (gigSets[activeSetIndex] && gigSets[activeSetIndex].name) ? gigSets[activeSetIndex].name : '';
  let nextIndex = 0;
  if (prevName){
    const found = gigSets.findIndex(s => (s.name||'') === prevName);
    if (found >= 0) nextIndex = found;
  }
  activeSetIndex = Math.max(0, Math.min(nextIndex, Math.max(gigSets.length - 1, 0)));

  updateSetSelector();
  setActiveSet(activeSetIndex);
  return true;
}





    function processAndRender() {
        const user = document.getElementById('userProfile').value.toLowerCase();
        const preserveOrder = !!activeSongs.__preserveOrder;

        // Dedup priority:
        // 1) if uid exists -> dedupe by uid
        // 2) else fallback to title|artist|version|singer
        const songMap = new Map();
        const orderKeys = [];

        activeSongs.forEach(s => {
            const content = s.content || '';
            const uid = (content.match(/\{uid:\s*(.*?)\}/i) || [null, s.uid || ''])[1].trim();
            const title = (content.match(/\{t(?:itle)?:\s*(.*?)\}/i) || [null, s.title || s.filename || 'Untitled'])[1].trim();
            const artist = (content.match(/\{artist:\s*(.*?)\}/i) || [null, s.artist || 'Unknown Artist'])[1].trim();
            const singer = (content.match(/\{singer:\s*(.*?)\}/i) || [null, s.singer || ''])[1].trim();
            const persona = (content.match(/\{persona:\s*(.*?)\}/i) || content.match(/\{p:\s*(.*?)\}/i) || content.match(/\{version:\s*(.*?)\}/i) || [null, s.persona || s.version || ''])[1].trim();
            const capo = (content.match(/\{capo:\s*(.*?)\}/i) || [null, null])[1];

            const key = `${title}||${artist}`;

            if (!songMap.has(key)) {
                songMap.set(key, { uid, title, artist, singer, persona, capo, content });
                orderKeys.push(key);
            } else {
                const existing = songMap.get(key);
                const existingMatches = firstToken(existing.persona) === firstToken(user);
                const currentMatches = firstToken(persona) === firstToken(user);
                if (!existingMatches && currentMatches) {
                    songMap.set(key, { uid, title, artist, singer, persona, capo, content });
                }
            }
        });

        const list = preserveOrder
            ? orderKeys.map(k => songMap.get(k)).filter(Boolean)
            : Array.from(songMap.values()).sort((a,b) => a.title.localeCompare(b.title));

        activeSongs.processed = list;
        currentIdx = Math.min(currentIdx, Math.max(0, list.length - 1));
        renderList(list);
        if (list.length > 0) displaySong(list[currentIdx], currentIdx);
    }

    function renderList(songs) {
        const cont = document.getElementById('setlistItems');
        cont.innerHTML = '';
        songs.forEach((s, i) => {
            const card = document.createElement('div');
            card.className = `song-card ${currentIdx === i ? 'active' : ''}`;
            const singerTxt = (s.singer || ((s.content||'').match(/\{singer:\s*(.*?)\}/i)||[,''])[1].trim());
            card.innerHTML = `<b>${s.title}</b><small>${s.artist}${singerTxt ? ' ‚Ä¢ üé§ '+singerTxt : ''}</small>`;
            card.onclick = () => { currentIdx = i; displaySong(s, i); renderList(songs); };
            cont.appendChild(card);
        });
    }

    function displaySong(s, idx) {
        // Title + artist line
        document.getElementById('headTitle').innerText = `${s.title || 'Untitled'}${(s.artist && String(s.artist).trim()) ? ` - ${s.artist}` : ''}`;
        const artistEl = document.getElementById('headArtist');
        artistEl.innerText = '';

        // Badges
        const meta = document.getElementById('metaContainer');
        meta.innerHTML = s.capo ? `<span class="badge">CAPO ${s.capo}</span>` : "";

        // Sheet identity banner (for testing persona/version picking)
        // Prefer parsed fields, but fall back to tags inside content.
        const content = s.content || '';
        const uid = (s.uid || (content.match(/\{uid:\s*(.*?)\}/i) || [null, ''])[1] || '').trim();
        const persona = (s.persona || (content.match(/\{persona:\s*(.*?)\}/i) || content.match(/\{p:\s*(.*?)\}/i) || content.match(/\{version:\s*(.*?)\}/i) || [null, ''])[1] || '').trim();
        const title = (s.title || (content.match(/\{t(?:itle)?:\s*(.*?)\}/i) || [null, 'Untitled'])[1] || 'Untitled').trim();
        const artist = (s.artist || (content.match(/\{artist:\s*(.*?)\}/i) || [null, ''])[1] || '').trim();

        const uidShort = uid ? uid.slice(0, 8) : 'no-uid';
        const filename = `${title}${artist ? ' - ' + artist : ''}${persona ? ' (' + persona + ')' : ''}.cho`;
        const banner = document.getElementById('gigBanner');
        if (banner) banner.textContent = '';

        // Expose current sheet info for the ‚ÑπÔ∏é modal
        const singer = (s.singer || (content.match(/\{singer:\s*(.*?)\}/i) || [null, ''])[1] || '').trim();
        const duration = (s.duration || (content.match(/\{duration:\s*(.*?)\}/i) || [null, ''])[1] || '').trim();
        const capoVal = (s.capo || (content.match(/\{capo:\s*(.*?)\}/i) || [null, ''])[1] || '').trim();
        window.__currentSheetInfo = {
          filename,
          uid: uid || '',
          uidShort,
          persona: persona || '',
          singer: singer || '',
          duration: duration || '',
          capo: capoVal || ''
        };

        // Render sheet
        renderChordPro(content);
    }

    function changeSong(dir) {
        let newIdx = currentIdx + dir;
        if (newIdx >= 0 && newIdx < activeSongs.processed.length) {
            currentIdx = newIdx;
            displaySong(activeSongs.processed[currentIdx], currentIdx);
            renderList(activeSongs.processed);
        }
    }

    function renderChordPro(content) {
        let finalHtml = "";
        let inChorus = false;
        
        // FIXED: Filter out consecutive empty lines to prevent large gaps
        const lines = content.split('\n').filter((line, index, arr) => {
            return !(line.trim() === "" && arr[index - 1]?.trim() === "");
        });

        lines.forEach(line => {
            let p = line.trim();
            const commentMatch = p.match(/\{c(?:omment)?:\s*(.*?)\}/i);
            
            if (commentMatch && commentMatch[1].toLowerCase() === "chorus") {
                if (inChorus) finalHtml += "</div>";
                inChorus = true;
                finalHtml += `<div class="chorus-container"><span class="p-section">CHORUS</span>`;
                return;
            }

            if ((p === "" || (commentMatch && commentMatch[1].toLowerCase() !== "chorus")) && inChorus) { 
                finalHtml += "</div>"; inChorus = false; 
            }

            if (commentMatch && commentMatch[1].toLowerCase() !== "chorus") {
                finalHtml += `<span class="p-section">${commentMatch[1]}</span>`;
                return;
            }
            
            if (p.startsWith('{')) return;
            let styledLine = p.replace(/\[([^\]]+)\]/g, `<span class="p-chord">$1</span>`);
            finalHtml += (styledLine || " ") + "\n";
        });

        if (inChorus) finalHtml += "</div>";
        document.getElementById('viewer').innerHTML = finalHtml;
        document.getElementById('viewer').scrollTop = 0;
    }

    function jumpTo(dest) { 
        const v = document.getElementById('viewer'); 
        v.scrollTo({ top: dest === 'end' ? v.scrollHeight : 0, behavior: 'smooth' }); 
    }

    function toggleSidebar() { const s = document.getElementById('sidebar'); s.style.display = s.style.display === 'none' ? 'flex' : 'none'; }
    function toggleOptions() { const p = document.getElementById('viewOptions'); p.style.display = p.style.display === 'block' ? 'none' : 'block'; }
    
// Persona dropdown: re-select correct songsheet versions and re-render
function wirePersonaChange(){
  const el = document.getElementById('userProfile');
  if (el && !el.__personaBound){
    el.__personaBound = true;
    el.addEventListener('change', () => {
      loadUserConfig();

      if (window.__gigPackV2) {
        rebuildGigSetsFromGigPackV2(getActivePersona());
      }

      processAndRender();
    });
  }

  // Sheet-info modal wiring (UI only)
  const infoBtn = document.getElementById('infoBtn');
  const infoModal = document.getElementById('infoModal');
  const infoText = document.getElementById('infoText');
  const infoClose = document.getElementById('infoClose');

  function openInfo(){
    if (!infoModal || !infoText) return;
    const i = window.__currentSheetInfo || {};
    const lines = [
      `Filename: ${i.filename || '(unknown)'}`,
      `UID: ${i.uid || ''}`,
      `Persona: ${i.persona || ''}`,
      `Singer: ${i.singer || ''}`,
      `Duration: ${i.duration || ''}`,
      `Capo: ${i.capo || ''}`
    ].filter(Boolean);
    infoText.textContent = lines.join('\n');
    infoModal.classList.remove('hidden');
  }
  function closeInfo(){
    if (!infoModal) return;
    infoModal.classList.add('hidden');
  }

  if (infoBtn && !infoBtn.__bound){
    infoBtn.__bound = true;
    infoBtn.addEventListener('click', openInfo);
  }
  if (infoClose && !infoClose.__bound){
    infoClose.__bound = true;
    infoClose.addEventListener('click', closeInfo);
  }
  if (infoModal && !infoModal.__bound){
    infoModal.__bound = true;
    infoModal.addEventListener('click', (e) => {
      if (e.target === infoModal) closeInfo();
    });
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', wirePersonaChange);
} else {
  wirePersonaChange();
}

// Initial theme/profile load
window.addEventListener('load', loadUserConfig);

// --- PWA / Offline cache ---
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./serviceWorker.js').catch(() => {});
  });
}

</script>
</body>
</html>